2024.5.28 星期二

##### break的注意事项和细节说明:

​    1.break 语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是那一层语句块
​    2.标签的基本使用

```java
        label1{
            label2{
                label3{
                    {
                        break label2;
                    }
                }
            }
        }
```

在实际的开发中，尽量不要使用。如果没有指定 break ，默认退出最近的循环体。

2024.5.30 星期四

#### 数组

​    数组的使用
​        使用方式1-动态初始化：数据类型[] 数组名 = new 数据类型[大小];
​        使用方式2-动态初始化: 1.先声明数组
​                                语法：数据类型 数组名[];也可以 数据类型[] 数组名; int[] a或者 int a[]
​                            2.创建数组
​                                语法：数组名 = new 数据类型[大小]; a = new int[10];
​        使用方式3-静态初始化：数据类型[] 数组名 = {元素值,元素值,......};

#####     数组使用注意事项和细节

​    1.数组是多个相同类型数据的组合，实现对这些数据的统一管理
​    2.数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
​    3.数组创建后,如果没有赋值,有默认值int 0, short 0, byte 0, long 0, float 0.0,double 0.0, char \u0000, boolean false, String null
​    4.使用数组的步骤 1.声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组
​    5.数组的下标是从0开始的。
​    6.数组下标必须在指定范围内使用，否则报:下标越界异常，比如int[] arr=new int[5]; 则有效下标为 0-4
​    7.数组属引用类型，数组型数据是对象(object)

    数组赋值机制
    1.基本数据类型赋值，这个值就是具体的数据，而且相互不影响。int n1 = 2;  int n2 = n1;
    2.数组在默认情况下是引用传递，赋的值是地址。

2024.6.1 星期五

### 类和对象

​    类和对象的内存分配机制
​    Java内存的结构分析
​	    1.栈:一般存放基本数据类型(局部变量)
​	    2.堆:存放对象(Cat cat，数组等)
​	    3.方法区:常量池(常量，比如字符串)，类加载信息
​	    4.示意图[Cat(name, age. price)]

######    Java内存的结构分析图

![image-20240601104013668](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240601104013668.png)

#### 成员方法

成员方法的好处：1.可以提高代码的复用性	2.可以将实现的细节封装起来，然后供其他用户调用即可。

##### 注意事项和使用细节

​	√ 形参列表
​		1.一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开,比如getSum(int n1,int n2)

​		2．参数类型可以为任意类型，包含基本类型或引用类型，比如printArr(int[][] map)

​		3．调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数!

​		4．方法定义时的参数称为形式参数，简称形参;

​		      方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须			一致!

​	√方法体

​		里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能		再定义方法!即:方法不能嵌套定义。 

##### <u>成员方法传参机制：</u>

<u>基本数据类型</u>：传递的是*值*(值拷贝)，形参的任何改变不影响实参!

<u>引用数据类型：</u>传递的是*地址*（传递的也是值，但值是地址），可以通过形参影响实参！

注意事项：

在方法内置空只是将p指向的地址变成null，原本的地址值仍然存在。

![image-20240601133712394](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240601133712394.png)

JVM的内存 

方法的**递归**调用

![image-20240602095724450](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240602095724450.png)

![image-20240602100938530](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240602100938530.png)

**递归重要规则**

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的，不会相互影响,比如n变量
3. 如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据.
4. 递归必须向退出递归的条件逼近，否则就是无限递归,出现(StackOverflowError，死龟了:)
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者

返回时，该方法也就执行完毕。

##### 方法重载

注意事项和使用细节

1. 方法名：必须相同
2. 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求）
3. 返回类型：无要求

##### 可变参数

基本概念：

java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现。

基本语法：

访问修饰符 返回类型 方法名(数据类型... 形参名){

}

例：1. int...   表示接受的是可变参数，类型是int ,即可以接收多个int(0-多)

​	2．使用可变参数时，可以当做数组来使用，即 nums 可以当做数组

```java
public int sum(int... nums){
}
```

注意事项和使用细节

1. 可变参数的实参可以为0个或任意多个。

2. 可变参数的实参可以为数组。

3. 可变参数的本质就是数组。

4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后。

   ```
   public void f2(String str, double... nums){
   
   }
   ```

5. 一个形参列表中只能出现一个可变参数。

##### 作用域

 基本使用

1. 在java编程中，主要的变量就是属性(成员变量)和局部变量。
2. 我们说的局部变量一般是指在成员方法中定义的变量。
3. java中作用域的分类

​		全局变量:也就是属性，作用域为整个类体

​		局部变量:也就是除了属性之外的其他变量，作用域为定义它的代码块中!

   4.<u>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。</u>

注意事项和细节使用

1. 属性和局部变量可以重名，访问时遵循就近原则。

2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。

3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。

   局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法调用过程中。

4. 作用域范围不同

   全局变量/属性:可以被本类使用，或其他类使用(通过对象调用)

   局部变量:只能在本类中对应的方法中使用

5. 修饰符不同

​	全局变量/属性可以加修饰符；局部变量不可以加修饰符

##### 构造方法/构造器

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成**对新对象的初始化**。

它有几个特点:

1. 方法名和类名相同
2. 没有返回值
3. 在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化

注意事项和使用细节

1. 一个类可以定义多个不同的构造器，即构造器重载。

   比如:我们可以再给Person类定义一个构造器,用来创建对象的时候,只指定人名,不需要指定年龄。

2. 构造器名和类名要相同。

3. 构造器没有返回值。

4. 构造器是完成对象的初始化.并不是创建对象。

5. 在创建对象时,系统自动的调用该类的构造方法。

6. 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造方法(也叫默认构造方法)。

7. <u>一旦定义了自己的构造器,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下。</u>

![image-20240602175543271](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240602175543271.png)

**流程分析（面试题）**

1. 加载Person类信息（Person.class），只会加载一次

2. 在堆中分配空间（地址）

3. 完成对象初始化 

   ​	3.1 默认初始化 age=0 name=null

   ​	3.2 显式初始化 age=90 name=null

   ​	3.3 构造器的初始化 age=20 name="黄豫湘"

4. 在对象在堆中的地址返回给p (p是对象名，也可以理解成是对象的引用)



##### this 关键字（传统的命名查找是就近原则，而this明确指向全局变量)

this的注意事项和使用细节

1. this关键字可以用来访问本类的属性、方法、构造器
2. this用于区分当前类的属性和局部变量
3. 访问成员方法的语法:this.方法名(参数列表);
4. 访问构造器语法:this(参数列表);***注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，必须放在第一条语句）***
5. this不能在类定义的外部使用，只能在类定义的方法中使用。



**访问修饰符**

![image-20240604201922282](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240604201922282.png)





### 面向对象三大特征：封装，继承，多态



#### 继承

注意事项和细节：

1. 子类继承了所有的属性和方法，非私有的属性和方法可以直接访问，但是私有属性不能在子类直接访问，要通过公共的方法去访问
2. 子类必须调用父类的构造器，完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表)
5. super在使用时，需要放在构造器第一行（super只能在构造器中使用）
6. super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器中
7. java所有类都是Object类的子类，Object是所有类的基类
8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）
9. 子类最多只能继承一个父类(指直接继承)，即java中是**单继承机制**。
10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系

**本质分析**（非常重要）

 这时请大家注意，要按照查找关系来返回信息
 （1）首先看子类是否有该属性
 （2）如果子类有这个属性，并且可以访问，则返回信息
 （3）如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息...)
 （4）如果父类没有就按照(3)的规则，继续找上级父类，直到Object...

如果父类中的属性为 private 时，子类的堆内存有，但是不能被子类直接调用

如果子类要调用age属性，父类中有一个私有的age属性，则不会找父类的父类中公开的age属性。

子类创建的内存布局图如下所示：

![image-20240605115833950](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240605115833950.png)

##### super关键字

基本介绍

super代表父类的引用，用于访问父类的属性、方法、构造器

基本语法

1. 访问父类的属性，但不能访问父类的private属性。	super.属性名;
2. 访问父类的方法，不能访问父类的private方法	super.方法名(参数列表);
3. 访问父类的构造器(这点前面用过):super(参数列表);只能放在构造器的第一句，只能出现一句!

super 给编程带来的便利/细节

1. 调用父类的构造器的好处(分工明确,父类属性由父类初始化，子类的属性由子类初始化)

2. 当子类中有和父类中的成员（属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果!

   ![image-20240606000538475](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240606000538475.png)

3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员;如果多个基类（上级类）中都有同名的成员，使用super访问遵循就近原则。A->B->C，当然也需要遵守访问权限的相关规则。

   ##### **super 和 this 的比较**

   ![image-20240607182612623](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240607182612623.png)



**方法重写**

注意事项和使用细节

1. 子类的方法的形参列表，方法名称，要和父类方法的形参列表，方法名称完全一样。

2. 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。

   比如 父类 返回类型是 Object ，子类方法返回类型是 String

3. 子类方法不能缩小父类方法的访问权限。

重写 和 重载 的区别

![image-20240607183225374](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240607183225374.png)



## 多态

1. 方法的多态，重写和重载就体现多态。

2. 对象的多态(核心，困难，重点)

   重要的几句话:

   (1)一个对象的编译类型和运行类型可以不一致

   (2)编译类型在定义对象时，就确定了，不能改变

   (3)运行类型是可以变化的
   
   (4)编译类型看定义时 = 号的左边，运行类型看 = 号的右边

多态注意事项和细节讨论

向上转型

```java
//向上转型:父类的引用指向了子类的对象
//语法:父类类型引用名= new子类类型();
Animal animal = new catO) ;
0bject obj = new cat;//可以吗？可以 0bject也是 Cat的父类

// 可以调用父类中的所有成员(需遵守访问权限)
// 但是不能调用子类的特有的成员
// 因为在编译阶段，能调用哪些成员，是由编译类型来决定的 
// animal.catchMouse();错误
// 最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法
// 然后调用，规则我前面我们讲的方法调用规则一致。
animal.eat();
animal.run();
animal.show();
animal.sleep();
```

向下转型

1. 语法: 子类类型  引用名  =  (子类类型)   父类引用
2. 只能强转父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是当前目标类型的对象
4. 可以调用子类类型中所有的成员

```java
//老师希望，可以调用Cat的catchMouse方法
//多态的向下转型
//(1)语法:子类类型 引用名 = (子类类型) 父类引用;
//问一个问题? cat的编译类型Cat,运行类型是Cat
Cat cat = (Cat) animal;
cat.catchNouse();//猫抓老鼠
//(2)要求父类的引用必须指向的是当前目标类型的对象
// Dog dog = (Dog) animal;//可以吗?
```

属性没有重写之说！属性的值看编译类型。

instanceOf 比较操作符，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

#### java的动态绑定机制*（非常非常重要）*

java重要特性：动态绑定机制

1. 当调用对象**方法**的时候，**该方法会和该对象的内存地址/运行类型**绑定
2. 当调用对象**属性**时，没有动态绑定机制，哪里声明，那里使用

多态的应用

1. 多态数组

   数组的定义为父类类型，里面保存的实际元素类型为子类类型

2. 多态参数

   方法定义的形参类型为父类类型，实参类型允许为子类类型



### Object类详解

- .equals()方法


​	== 和 equals 的对比**（面试题）**

​	== 是一个比较运算符

1. ==：既可以判断基本类型，又可以判断引用类型
2. ==：如果判断基本类型，判断的值是否相等。
3. ==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象。
4. equals：是Object类中的方法，只能判断引用类型。
5. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer，String

- .hashcode()方法


1. 提高具有哈希结构的容器的效率!
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的!
3. 两个引用，如果指向的是不同对象，则哈希值是不一样的
4. 哈希值主要根据地址号来的!，不能完全将哈希值等价于地址。
5. 案例演示[HashCode_.java]: obj.hashCode() [测试:A obj1 = new AO; A obj2 = new A);Aobj3 = obj1]
6. 后面在集合，中hashCode如果需要的话，也会重写

- .toString()方法


1. 基本介绍

   默认返回：全类名 + @ + 哈希值的十六进制

   子类往往重写toString方法，用于返回对象的属性信息

2. 重写toString()方法，打印对象或拼接对象时，都会自动调用该对象的toString形式.

   ```java
   // 没有重写默认调用Object类中的toString方法
   System.out.println(monster.toString());// com.javaexec.object_.Monster@1b6d3586
   ```

3. 当直接输出一个对象时,toString()方法会被默认调用

   ```java
   System.out.println(monster.toString());//Monster{name='小妖怪', job='巡山', sal=1000.0}
   System.out.println("==当直接输出一个对象时，toString方法会被默认的调用==");
   System.out.println(monster);//Monster{name='小妖怪', job='巡山', sal=1000.0}
   ```


- finalize()方法

1. 当对象被回收时，系统自动调用该对象的finalize()方法。子类可以重写该方法,做一些释放资源的操作
2. 什么时候被回收:当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法
3. 垃圾回收机制的调用，是由系统来决定（即有自己的GC机制）,也可以通过System.gc()主动触发垃圾回收机制



**断点调试**

快捷键

F7（跳入） F8（跳过）	shift+F8（跳出）	F9（resume，执行到下一个断点）

F7:跳入方法内

F8:逐行执行代码

shift + F8:跳出方法



# 				第二阶段

##### **类变量和类方法**

**类变量**

- 类变量内存布局：

![image-20240608214722916](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240608214722916.png)

有些书说在方法区...，jdk版本有关系，*记住一点*：static 变量是对象共享

不管static变量在哪里，共识：

1.  static 变量是同一个类所有对象共享。
2.  static 类变量，在类加载的时候就生成了。

- 介绍：

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量。这个从前面的图也可看出来。

- 语法：

​	访问修饰符  static  数据类型  变量名;  [推荐]

​	static  访问修饰符  数据类型  变量名;

- 如何使用类变量

​	类名.类变量名

​	或者  对象名.类变量名      [静态变量的访问修饰符的访问权限和范围和普通属性是一样的。]

​	推荐使用：类名.类变量名

```java
public static void main(String[] args){
    // 类名.类变量名
    // 说明:类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问
    System.out.println(A.name)
}
class A{
    // 类变量
    // 静态变量的访问修饰符的访问权限和范围和普通属性是一样的
    public static String name = "黄豫湘";
}
```

- 类变量使用注意事项和细节讨论

1. 什么时候需要用类变量

   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量):比如:定义学生类，统计

   所有学生共交多少钱。

2. 类变量与实例变量(普通属性)区别

   类变量是该类的所有对象共享的，而实例变量是每个对象独享的。

3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

4. 类变量可以通过类名.类变量名或者对象名.类变量名来访问，但java设计者推荐我们使用类名.类变量名方式访

   问。【前提是满足访问修饰符的访问权限和范围】

5. 实例变量不能通过  类名.类变量名  方式访问。

6. 类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了。

7. 类变量的生命周期是随类的加载开始，随着类消亡而销毁。类变量只加载一次。



**类方法**

- 介绍

​	类方法也叫静态方法。‘

​	形式如下：访问修饰符  static   数据返回类型   方法名(){  }【推荐】

​				static   访问修饰符   数据返回类型   方法名(){    }

- 类方法的调用:

​	使用方式:	类名.类方法名	或者	对象名.类方法名 【前提是满足访问修饰符的访问权限和范围】

- 类方法经典的使用场景

  当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。

  比如:工具类中的方法 utils

  Math类、Arrays类、Collections集合类看下源码:

- 小结

  在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了，比

  如打印一维数组，冒泡排序。完成某个计算任务等.

- 类方法使用注意事项和细节讨论

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区:

   类方法中无this的参数

   普通方法中隐含着this的参数

2. 类方法可以通过类名调用，也可以通过对象名调用。[举例]

3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。[举例]

4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以。

5. 类方法(静态方法)中只能访问静态变量或静态方法。【如何理解】

6. 普通成员方法，既可以访问非静态成员，也可以访问静态成员。

小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员(必须遵守访问权限)



**main方法**

深入理解main方法

解释main方法的形式:public static void main(String[] args){}

1. main方法时虚拟机调用

2. java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public
3. java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static
4. 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数案例演示，接收参数.
5. java  执行的程序  参数1  参数2  参数3

特别提示:

1. 在main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性。
2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员,

**代码块**

●基本介绍

代码化块又称为**初始化块**,属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{ }

 包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用,而是加载类、

时，或创建对象时隐式调用。

●基本语法

```java
[修饰符]{
	//代码;
};
```

注意:

1) 修饰符可选,要写的话，也只能写static

2) 代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块

3) 逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)

4) ;号可以写上,也可以省略。

- 代码块的好处和案例演示

老师理解:

1) 相当于另外一种形式的构造器(对构造器的补充机制)，可以做初始化的操作

2) 场景:如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

3) 代码块的快速入门

- 代码块使用注意事项和细节讨论

1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着**类的加载**而执行，并且**只会执行一次**。如果是普通代码块，每创建一个对象，就执行。

2. 类什么时候被加载**( 重要！！！背下来)**

   1) 创建对象实例时(new)

   2) 创建子类对象实例，父类也会被加载。而且，父类先被加载，子类后被加载

   3) 使用类的静态成员时(静态属性,静态方法)

      案例演示:A类 extends B类 的静态块

3. 普通的代码块，在创建对象实例（new 对象）时，会被隐式的调用。被创建一次，就会调用一次。
   如果只是使用类的静态成员时，普通代码块并不会执行。

4. 创建一个对象时，在**一个类调用顺序是  **(重点，难点)∶

   1) 调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)
   2) 调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样,如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用)
   3) 调用构造方法。

5) 构造方法(构造器)的最前面其实隐含了super()和调用普通代码块，新写一个类演示[截图+说明],

   静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的.

6) 我们看一下创建一个**子类时(继承关系)**，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的**调用顺序**如下:
   1. 父类的静态代码块和静态属性(优先级一样,按定义顺序执行)
   2. 子类的静态代码块和静态属性(优先级一样，按定义顺序执行)
   3. 父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
   4. 父类的构造方法
   5. 子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
   6. 子类的构造方法**//面试题**
      A，B,  C 类演示【10Min ]55 CodeBlockDetail04.java

7) 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员。



**单例设计模式**

- 什么是单例模式	单例(单个的实例)
  1. 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法
  2. 单例模式有两种方式:1)  饿汉式         2)   懒汉式

- 单例模式应用实例

  演示饿汉式和懒汉式单例模式的实现。

  [单例模式-饿汉式]步骤如下:（饿汉式可能造成创建了对象，但是没有使用）

  1) 构造器私有化，防止直接 new
  2) 类的内部创建对象

  3) 向外暴露一个静态的公共方法 getInstance

  4) 代码实现

     ```java
     // 为什么是饿汉式？
     class GirlFriend{
         private String name;
         //为了能够在静态方法中，返回gf对象，需要将其修饰为static
         private static GirlFriend gf = new GirlFriend("小红");
     
         // 如何保障我们只能创建一个GirlFriend 对象
         // 步骤[单例模式-饿汉式]
         // 1.将构造器私有化
         // 2.在类的内部直接创建(该对象是 static )
         // 3.提供一个公共的static方法，返回 gf 对象
         private GirlFriend(String name) {
             this.name = name;
         }
     
         public static GirlFriend getInstance(){
             return gf;
         }
     
     }
     
     GirlFriend girlFriend = GirlFriend.getInstance();
     System.out.println(GirlFriend.n1);
     // 因为上面调用的虽然是GirlFriend.n1属性，构造器并未使用但已经加载，因此称为饿汉式
     ```

  [单例模式-懒汉式]步骤如下:

  只有当用户使用getInstance时，才返回Cat对象，后面再调用时，会返回上次创建的Cat对象，从而保证了单例。

  1) 构造器私有化，防止直接 new
  2) 定义一个static静态属性对象

  3) 提供一个 public 的static 方法，可以返回一个Cat对象

  4) 代码实现

     ```java
     // 懒汉式
     class Cat {
         private String name;
         public static int n1 = 999;
         private static Cat cat;
         
         // 步骤
         // 1.仍然构造器私有化
         // 2.定义一个static静态属性对象
         // 3.提供一个 public 的static 方法，可以返回一个Cat对象
         
         private Cat(String name) {
             System.out.println("构造器被调用");
             this.name = name;
         }
     
         public static Cat getInstance() {
             if (cat == null) {
                 cat = new Cat("小可爱");
             }
             return cat;
         }
     }
     ```

饿汉式和懒汉式的区别：

1. 二者最主要的区别在于创建对象的时机不同:饿汉式是在类加载就创建了对象实例,而懒汉式是在使用时才创建。

2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。(后面学习线程后，会完善·一把)

3. 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。

4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式。

   

**final关键字**

final中文意思:最后的,最终的.

final可以修饰类、属性、方法和局部变量.

在某些情况下,程序员可能有以下需求，就会使用到final:

1) 当不希望类被继承时,可以用final修饰.【案例演示】

2) 当不希望父类的某个方法被子类覆盖/重写(override)时,可以用final关键字修饰。【案例演示:访问修饰符 final返回类型  方法名】

3) 当不希望类的的某个属性的值被修改,可以用final修饰.【案例演示: public final double TAX_RATE=0.08】

4) 当不希望某个局部变量被修改，可以使用final修饰【案例演示: final double TAX_RATE=0.08 】 

5) **final 修饰数组时，数组的地址不能被修改，但其中的数据可以改变**   

- 使用注意事项和细节讨论

1. final修饰的属性又叫常量,一般用XX_XX_XX来命名

2. final修饰的属性在定义时,必须赋初值,并且以后不能再修改，赋值可以在如下位置之一【选择一个位置赋初值即可】:
   ①定义时:如public final double TAX_RATE=0.08;

   ②在构造器中

   ③在代码块中。

3. 如果final修饰的属性是静态的，则初始化的位置只能是

   ①定义时

   ②在静态代码块，不能在构造器中赋值。

4. final类不能继承,但是可以实例化对象。[A2类]

5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。[A3类]

6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法。

7. final不能修饰构造方法(即构造器)

8. final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理。

   ```java
   class Demo{
   public static final int i=16;
       static{
   	System.out.printIn("hyx~");
       }
   }
   ```

9) 包装类(Integer,Double,Float,Boolean等都是final) ,   String也是final类。

```java
public class Something { 
public int addOne(final int x){//下面的代码是否有误，为什么?
    ++x;	//错误,原因是不能修改final x的值
	return x + 1;//这里是可以
	}
}
```



**抽象类**

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。

当父类的一些方法不能确定时,可以用abstract关键字来修饰该方法，这个方法就是抽象方法.用abstract来修饰该类就是抽象类。

- 抽象类的介绍

1) 用abstract关键字来修饰一个类时,这个类就叫抽象类

   访问修饰符  abstract  类名{
   }

2)  用 abstract 关键字来修饰一个方法时,这个方法就是抽象方法
   访问修饰符  abstract  返回类型  方法名(参数列表);//没有方法体

3) 抽象类的价值更多作用是在于设计,是设计者设计好后，让子类继承并实现抽象类()

4) 抽象类,是考官比较爱问的知识点,在框架和设计模式使用较多

- 抽象类使用的注意事项和细节讨论 

1) 抽象类不能被实例化
2) 抽象类不一定要包含abstract方法。也就是说,抽象类可以没有abstract方法
3) 一旦类包含了abstract方法,则这个类必须声明为abstract 
4) abstract只能修饰类和方法，不能修饰属性和其它的。
5) 抽象类可以有任意成员【**因为抽象类还是类**】，比如:非抽象方法、构造器、静态属性等等
6) 抽象方法不能有主体，即不能实现
7) 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。
8) 抽象方法不能使用private、final和 static来修饰，因为这些关键字都是和重写相违背的。

- 抽象类最佳实践-模板设计模式

基本介绍：抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

能解决的问题：

1) 当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现
2) 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式.



**接口**

- 基本介绍

  接口就是给出一些没有实现的方法,封装到一起,到某个类要使用的时候,在根据具体情况把这些方法写出来。

  - 小结:

    1.在Jdk7.0前接口里的所有方法都没有方法体，即都是抽象方法。

    2.Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现，**但必须需要使用 default 或者 static 关键字修饰**。

    interface 中的方法：1、抽象方法	2、默认实现方法	3、静态方法

- 注意事项和细节

  1) 接口不能被实例化

  2) 接口中所有的方法是 public方法，接口中抽象方法，可以不用abstract修饰

  3) 一个普通类实现接口,就必须将该接口的所有方法都实现

  4) 抽象类实现接口，可以不用实现接口

  5) 一个类同时可以实现多个接口

  6) 接口中的属性,只能是final的，而且是public static final 修饰符。

     比如:int a=1;实际上是public static final int a=1; (必须初始化)

     ```java
     interface A{
     	int n1 = 10;//等价于 public static final int n1 = 10;
     }
     ```

  7) 接口中属性的访问形式:接口名.属性名

  8) 一个接口不能继承其它的类,但是可以继承多个别的接口[举例]
     interface A extends B,C

  9) 接口的修饰符只能是public和默认，这点和类的修饰符是一样的。

- 接口和继承的关系

  实现接口vs继承类

  1) 接口和继承解决的问题不同

     继承的价值主要在于:解决代码的**复用性和可维护性。**

     接口的价值主要在于:设计，设计好**各种规范**(方法)，让其它类去实现这些方法。

  2) 接口比继承更加灵活

     接口比继承更加灵活，继承是满足is - a的关系，而接口只需满足like - a的关系。

     接口在一定程度上实现代码解耦，[即:接口规范性+动态绑定机制]。

- 接口的多态特性

  1) 多态参数(前面案例体现)
     在前面的 Usb 接口案例，Usb usb，既可以接收手机对象，又可以接收相机对象，就体现了接口多态(接口引用可以指向实现了接口的类的对象)

     ```java
     public class InterfacePloyParameter {
         public static void main(String[] args) {
             // 接口多态体现
             // 接口类型的变量 ia 可以指向 实现了IA接口的对象实例
             IA ia = new A1();
             ia = new A2();
             // 继承体现的多态
             // 父类类型的变量 ia 可以指向 实现了P1接口的对象实例
             P1 p1 = new A1();
             p1 = new A2();
         }
     }
     interface IA{ }
     // 父类
     class P1{}
     class A1 extends P1 implements IA{}
     class A2 extends P1 implements IA{}
     
     ```

  2) 多态数组
     演示一个案例:给Usb数组中，存放 Phone 和 相机对象，Phone类还有一个特有的方法call()，请遍历Usb数组，如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用Phone特有方法 call.

     ```java
     public class InterfacePloyArr {
         public static void main(String[] args) {
             // 多态数组 -> 接口类型的数组
             Usb[] usbs = new Usb[2];
             usbs[0] = new Camera_();
             usbs[1] = new Phone_();
             /*
             演示一个案例:给Usb数组中，存放 Phone 和 相机对象，Phone类还有一个特有的方法call()，请遍历Usb数组，
             如果是Phone对象，除了调用Usb接口定义的方法外，还需要调用Phone特有方法 call.
              */
             for (int i = 0; i < usbs.length; i++) {
                 usbs[i].work();// 动态绑定机制
                 // 和前面一样，我们仍然需要进行类型的向下转型
                 if (usbs[i] instanceof  Phone_){
                     Phone_ phone = (Phone_) usbs[i];
                     phone.call();
                 }
             }
         }
     }
     
     interface Usb{	 void work();	}
     class Phone_ implements Usb{
         public void call(){
             System.out.println("手机可以打电话");
         }
         @Override
         public void work() {
             System.out.println("手机工作中");
         }
     }
     class Camera_ implements Usb{
         @Override
         public void work() {
             System.out.println("相机工作中");
         }
     }
     ```

  3) 接口存在多态传递现象

     ```java
     /**
      * 演示多态传递现象
      */
     public class InterfacePloyPass {
         public static void main(String[] args) {
             // 接口类型的变量可以指向，实现了该接口的类的对象实例
             IG ig = new Teacher();
             //如果IG继承了IH接口，而Teacher类实现了IG接口
             //那么，实际上就相当于 Teacher类也实现了IH接口。
             IH ih = new Teacher(); // 多态传递
         }
     }
     
     interface IH{ }
     interface IG extends IH{ }
     class Teacher implements IG{ }
     
     ```

     

小结：类的五大成员（1）属性（2）方法（3）构造器（4）代码块（5）内部类



#### **内部类(重难点！！！)** 

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部(outer class)。是我们类的第五大成员【思考:类的五大成员是哪些?】，内部类最大的特点就是**可以直接访问私有属性**，并且可以体现类与类之间的包含关系。放在方法或者代码块中。

- 基本语法

  ```java
  class Outer{ //外部类
      class inner{ // 内部类   
      }
  }
  class Other{ // 外部其他类    
  }
  ```

- 内部类的分类(四种)

  - 定义在外部类局部位置上(比如方法内):
    1) 局部内部类(有类名)
    2) 匿名内部类(没有类名，**重点!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!**)

  - 定义在外部类的成员位置上:
    1. 成员内部类(没用static修饰)
    2. 静态内部类(使用static修饰)

**局部内部类**

说明:局部内部类是定义在外部类的局部位置，比如方法中，并且有类名.

1. 可以直接访问外部类的所有成员，包含私有的

2. 不能添加访问修饰符,因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final修饰,因为局部变量也可以使用final

3. 作用域:仅仅在定义它的方法或代码块中。

4. 局部内部类---访问---->外部类的成员[访问方式:直接访问]

5. 外部类---访问---->局部内部类的成员
   访问方式:创建对象,再访问(注意:必须在作用域内)

6. 外部其他类---不能访问----->局部内部类（因为局部内部类地位是一个局部变量)

7. 如果外部类和局部内部类的成员重名时，*默认遵循就近原则*，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

   ```java
   // 演示
   System.out.println("外部类的n2=" + 外部类名.this.n2);
   ```

记住：

1. 局部内部类定义在方法中/代码块
2. 作用域在方法体或者代码块中
3. 本质仍然是一个类



**匿名内部类（重要！！！！！！！！！！！！！！！！！！！！！！！！！！）**

// (1) 本质是类 （2）内部类（3）该类没有名字（4）同时还是一个对象

说明：说明:匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名

1. 匿名内部类的基本语法

   new 类或接口(参数列表){	

   ​	类体

   };

2. 匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点,因此可以调用匿名内部类方法。

3. 可以直接访问外部类的所有成员，包含私有的[案例演示]

4. 不能添加访问修饰符,因为它的地位就是一个局部变量。[过]

5. 作用域:仅仅在定义它的方法或代码块中。[过]

6. 匿名内部类---访问---->外部类成员[访问方式:直接访问]

7. 外部其他类---不能访问----->匿名内部类（因为匿名内部类地位是一个局部变量)

8. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

```java
 		// 基于接口的匿名内部类：
        A tiger = new A() {
            @Override
            public void cry() {
                System.out.println("老虎叫");
            }
        };
        tiger.cry();
        System.out.println("tiger的运行类型为" + tiger.getClass());
        // 基于类的匿名内部类：
        // 1.father 的编译类型 Father
        // 2.father 的运行类型 Outer04$2 就是匿名内部类
        // 3.注意("jack") 参数列表会传递给构造器
        Father father = new Father("jack") {
            @Override
            public void test() {
                System.out.println("匿名内部类重写了test方法");
            }
        };
        System.out.println("father的运行类型：" + father.getClass());
        father.test();
        // 基于抽象类的匿名内部类，必须实现抽象方法
        Animal animal = new Animal() {
            @Override
            void eat() {
                System.out.println("小狗吃骨头");
            }
        };
        animal.eat();
    }
}

interface A {
    void cry();
}
class Father {
    public Father(String name) {
    }
    public void test() {
    }
}
abstract class Animal {
    abstract void eat();
}
```

**成员内部类**

说明:  成员内部类是定义在外部类的成员位置,并且没有static修饰。

1. 可以直接访问外部类的所有成员，包含私有的

2. 可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。

3. 作用域

   和外部类的其他成员一样:为整个类体

   比如前面案例,在外部类的成员方法中创建成员内部类对象，再调用方法.

4. 成员内部类---访问---->外部类(比如:属性）[访问方式:直接访问] (说明)

5. 外部类---访问------>成员  内部类(说明)访问方式:创建对象,再访问

6. 外部其他类---访问---->成员内部类

7. 如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员,则可以使用(外部类名.this.成员)去访问

   ```java
   public class Homework07 {
       public static void main(String[] args) {
           // 外部其他类，使用成员内部类的两种方法
           Car car = new Car(90);
           // 第一种方式
           Car.Air air = car.new Air();
           air.flow();
           // 第二种方式：在外部类中，编写一个方法，可以返回 Air 对象
           Car.Air airInstance = car.getAirInstance();
       }
   
   }
   class Car {
       private int temperature;
   
       public Car(int temperature) {
           this.temperature = temperature;
       }
   	// 成员内部类
       class Air {
       }
       
       public Air getAirInstance(){
           return new Air();
       }
   }
   ```

   

**静态内部类**

说明:静态内部类是定义在外部类的成员位置，并且有static修饰

1) .可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员

2) 可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员

3) 作用域：同其他的成员，为整个类体

4) 静态内部类---访问---->外部类(比如:静态属性)[访问方式:直接访问所有静态成员]

5) 外部类---访问------>静态内部类访问方式:创建对象,再访问

6) 外部其他类---访问----->静态内部类

   ```java
   // 方式1
   // 因为静态内部类,是可以通过类名直接访问(前提是满足访问权限)
   Outer10.Inner10 inner10 = new Outer10.Inner10();
   inner10.say();
   // 方式2
   // 编写一个方法,可以返回静态内部类的对象实例.
   // 方式3
   // 编写一个静态方法,通过  类名.方法名  可以返回静态内部类的对象实例.
   ```

7) 如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员)去访问



**枚举**

1) 枚举对应英文(enumeration,简写 enum)
2) 枚举是一组常量的集合。
3) 可以这里理解:枚举属于一种特殊的类，里面只包含一组有限的特定的对象。

- 实现方式：

1. 自定义实现枚举

   1) 不需要提供setXxx方法，因为枚举对象值通常为只读.
   2) 对枚举对象/属性使用final + static共同修饰，实现底层优化.
   3) 枚举对象名通常使用全部大写，常量的命名规范.
   4) 枚举对象根据需要，也可以有多个属性

   小结：进行自定义类实现枚举，有如下特点：

   1) 构造器私有化
   2) 本类内部创建一组对象
   3) 对外暴露对象（通过为对象添加public final static修饰符）
   4) 可以提供 get 方法，但是不要提供 set

   ```java
   // 演示自定义枚举实现
   // 1. 将构造器私有化,目的防止直接new
   // 2. 去掉setXxx方法,防止属性被修改
   // 3. 在Season 内部，直接创建固定的对象
   class Season {
       private String name;
       private String desc;
   
       public static final Season SPRING = new Season("春天", "温暖");
       public static final Season SUMMER = new Season("夏天", "炎热");
       public static final Season AUTUMN = new Season("秋天", "凉爽");
       public static final Season WINTER = new Season("冬天", "寒冷");
   
       private Season(String name, String desc) {
           this.name = name;
           this.desc = desc;
       }
   ```

2) 使用enum关键字实现枚举

   使用enum来实现前面的枚举案例，看老师演示，主要体会和自定义类实现枚举不同的地方

   ```java
   public class Enumeration03 {
       public static void main(String[] args) {
           System.out.println(Season2.AUTUMN);
       }
   }
   enum Season2 {
       // 如果使用了 enum 来实现枚举类
       // 1.使用关键字 enum 代替 class
       // 2.public static final Season SPRING = new Season2("春天", "温暖");直接使用
       // SPRING("春天","温暖") 解读 常量名 (实参列表)
       // 3.如果有多个常量(对象)，使用 ,号间隔即可
       // 4.如果使用 enum 来实现枚举，要求将定义常量对象，写在前面
       // 5.如果我们使用的是无参构造器，创建常量对象，则可以省略()
       SPRING("春天", "温暖"),
       SUMMER("夏天", "炎热"),
       AUTUMN("秋天", "凉爽"),
       WINTER("冬天", "寒冷");
       private String name;
       private String desc;
   
       private Season2(String name, String desc) {
           this.name = name;
           this.desc = desc;
       }
   }
   ```

- enum关键字实现枚举注意事项
  1) 当我们使用enum 关键字开发一个枚举类时，默认会继承 Enum 类[如何证明]
  2) 传统的public static final Season2 SPRING = new Season2("春天","温暖");简化成SPRING("春天","温暖")，这里必须知道，它调用的是哪个构造器.
  3) 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略
  4) 当有多个枚举对象时，使用  **,**  间隔，最后有一个分号结尾
  5) 枚举对象必须放在枚举类的***行首***.
  6) 枚举类的构造器默认 private

- enum常用方法应用实例

  我们一起来举例说明 enum 常用的方法的使用，对 Season2测试. EnumMethod.java

  1) toString : Enum类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息
  2) name :  返回当前对象名 (常量名)，子类中不能重写
  3) ordinal : 返回当前对象的位置号，默认从0开始
  4) values : 返回当前枚举类中所有的常量
  5) valueOf : 将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常!
  6) compareTo : 比较两个枚举常量，比较的就是*位置号*!

- enum 实现接口

  1) 使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承Enum.而 Java 是单继承机制。

  2) 枚举类和普通类一样，可以实现接口，如下形式。

     enum  类名  implements  接口1,接口2{}



**注解**

1) 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。

3) 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。

4) 使用 Annotation 时要在其前面增加@符号,并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素

   三个基本的 Annotation：

   - @Override:限定某个方法,是重写父类方法,该注解只能用于方法
   - @Deprecated:用于表示某个程序元素(类,方法等)已过时
   - @SuppressWarnings:抑制编译器警告

@Override使用说明：

1) @Override表示指定重写父类的方法（从编译层面验证)，如果父类没有fly方法，则会报错
2) 如果不写@Override注解,而父类仍有public void fly(){}，仍然构成重写
3) @Override 只能修饰方法，不能修饰其它类，包，属性等等
4) 查看@Override注解源码为@Target(Element Type.METHOD),说明只能修饰方法
5) @Target是修饰注解的注解，称为元注解

@Deprecated的说明：

1) 用于表示某个程元素(类,方法等)已过时
2) 可以修饰方法，类，字段,包,参数等等
3) @Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD,PACKAGE,PARAMETER,TYPE))
4) @Deprecated的作用可以做到新旧版本的兼容和过渡

@SuppressWarnings注解的案例

说明各种值

1) unchecked是忽略没有检查的警告
2) rawtypes是忽略没有指定泛型的警告(传参时没有指定泛型的警告错误)
3) unused是忽略没有使用某个变量的警告错误
4) @SuppressWarnings可以修饰的程序元素为,查看@Target
5) 生成@SupperssWarnings时，不用背，直接点击左侧的黄色提示，就可以选择(注意可以指定生成的位置)

元注解的种类(使用不多，了解,不用深入研究)
1) Retention//指定注解的作用范围,三种SOURCE,CLASS,RUNTIME
2) Target!/指定注解可以在哪些地方使用
3) Documented//指定该注解是否会在javadoc体现
4) Inherited //子类会继承父类注解



## 						异常

- 基本概念：Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)

  执行过程中所发生的异常事件可分为两类：

1. Error(错误):Java虚拟机无法解决的严重问题。如:JVM系统内部错误、资源耗尽等严重情况。比如:

  StackOverflowError[栈溢出]和OOM(out of memory). Error是严重错误,程序会崩溃。

2. Exception:其它因编程错误或偶然的外在因素导致的一般性问题,可以使用针对性的代码进行处理。例如空指针访问，试图读取不存在的文件，网络连接中断等等，Exception分为两大类:运行时异常和编译时异常。

- 异常体系图（！！）

小结：

1) 异常分为两大类,运行时异常和编译时异常.
2) 运行时异常，编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常
3) 对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响
4) 编译时异常，是编译器要求必须处置的异常。

**异常处理**

- 基本介绍
  异常处理就是当异常发生时，对异常处理的方式。
- 异常处理的方式（如果程序员，没有显示是处理异常，默认throws）
  1) try-catch-finally
  程序员在代码中捕获发生的异常，自行处理
  1)  throws
  将发生的异常抛出，交给调用者(方法)来处理，最顶级的处理者就是JVM

把自定义异常做成运行时异常，好处时，我们可以使用默认的处理机制。

- throw 和 throws 的区别

​			     意义					位置				后面跟的东西
throws	异常处理的一种方式		方法声明处				异常类型
throw	手动生成异常对象的关键字	方法体中				  异常对象



#### **包装类**

- 包装类和基本数据的转换

  演示 包装类 和 基本数据类型 的相互转换,这里以int 和 Integer演示。

  1) jdk5前的手动装箱和拆箱方式，装箱:基本类型->包装类型,反之，拆箱
  2) jdk5以后(含jdk5)的自动装箱和拆箱方式

  3) 自动装箱底层调用的是valueOf方法，比如Integer.valueOf()

```java
        // 演示int <--> Integer 的装箱和拆箱
        // jdk5前是手动装箱和拆箱
        // 手动装箱 int --> Integer
        int n1 = 100;
        Integer integer = new Integer(n1);
        Integer integer1 = Integer.valueOf(n1);

        //手动拆箱
        //Integer -> int
        int i = integer.intValue();

        // jdk5后，就可以自动装箱和自动拆箱
         int n2 = 200;
        // 自动装箱int->Integer
        Integer integer2 = n2;//底层使用的是Integer.valueOf(n2)
        //自动拆箱Integer->int
         int n3 = integer2;
```

![image-20240612102100931](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240612102100931.png)

​	**三元运算符是一个整体，要看精度最高的那个。（面试题）**

- 包装类型和String类型的相互转换

  ```java
          //包装类(Integer)->String
          Integer i = 100;//自动装箱
          // 方式1
          String str1 = i + "";
          // 方式2
          String str2 = i.toString();
          // 方式3
          String str3 = String.valueOf(i);
  
          //String ->包装类(Integer)
          String str4 = "12345";
          Integer i2 = Integer.parseInt(str4);//使用到自动装箱
          Integer i3 = new Integer(str4); // 构造器
  ```

  - 面试题

![image-20240612104411070](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240612104411070.png)

```java
要点：This method will always cache values in the range -128 to 127
  public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

![image-20240612110036968](C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240612110036968.png)

​	示例七中的 == 判断的是值，因为有一边是基本数据类型，Integer执行了自行拆箱功能



#### **String类**

- String类的理解和创建对象

  1) String 对象用于保存字符串，也就是一组字符序列 

  2) 字符串常量对象是用双引号括起的字符序列。例如:"你好"、"12.97"."boy"等·

  3) 字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节。

  4) String类较常用构造方法(其它看手册):

     String s1 = new String()；

     String s2 = new String(String original);

     String s3 = new String(char\[] a);

     String s4 = new String(char[]a,int start Index,int count);

  5) String 类实现了 接口 Serializable 【String 可以串行化:可以在网络传输】                   

     ​				接口Comparable 【String对象可以比较大小】

  6) String是final类，不能被其他的类继承，代表不可变的字符序列。

  7) String有属性 private final char value[];用于存放字符串内容'

  8) 一定要注意:value 是一个final类型，不可以修改(需要功力,指的是数据存放的地址)。

- 创建String对象的两种方式

  方式一:直接赋值String s = "hyx";

  方式二:调用构造器 String s = new String("hyx");

  1) 方式一:先从常量池查看是否有"hyx”数据空间，如果有，直接指向;如果没有则重新创建，然后指向。s最终指向的是*常量池*的空间地址
  2) 方式二:先在堆中创建空间，里面维护了value属性，指向常量池的hyx空间。
     如果常量池没有"hyx"，重新创建,如果有，直接通过value指向。最终指向的是*堆中*的空间地址。
  3) 画出两种方式的内存分布图

<img src="C:/Users/32596/AppData/Roaming/Typora/typora-user-images/image-20240612112910197.png" alt="image-20240612112910197" style="zoom: 80%;" />



































































































































































































































